## MySQL

**MySQL优化：**

MySQL执行流程：

客户端/ pdo/navicat/mysqli

-> MySQL connection 

-> 连接管理[身份认证、密码认证、]

-》 用户模块 《- 线程

-》命令分发器 -》 SQL令牌

-》查询缓存 -》

-》查询优化器 -》 索引最优选择

-》访问控制模块，是否有操作权限

-》存储引擎接口

----

**事务及隔离级别：**

- 读未提交

- 读已提交

- 重复读： 脏读、不可重复度。通过间隙锁解决幻读问题

- 序列化



**排他锁和共享锁**



----

**日志：**

slow log

error 

binlog

redo ,undo 

中继日志

----

**MySQL优化：**

数据结构选择：

1. 字符串：char varchar text blob

char 固定长度，比如密码

varchar 大于5000 用text

text 单独拿出来

blob 尽量避免 使用磁盘存储

2. 整数 ：

int

tinyint

bigint

decimal () 精度好

3. 时间：

datetime：8个字节，不会改变

timestamp ：会改变 

int：



4. 尽量不要有null，索引会保存其他，判断时会有问题。占据更多的存储空间



----



**explain：**



- type  ：

all 全表扫描

index 使用索引

range between and < > in or

ref  使用索引但值不唯一

const 使用主键查询



- prossible key

- key



- extra :use where use index;null ; 



----

**索引类型**：hash 、 fulltext 、 btree

**二分查找法：**

非叶子节点：保存索引 

叶子节点：保存索引的值，联合索引的值，和主键ID。数据存放在表页中，16k。



每次插入修改时索引会移动，旋转，是数据尽量均衡



**主键int类型**

----

**索引可能失效的原因：**

最左匹配，索引回表，类型不匹配，or【并不一定失效，联合索引】

索引选择：

优先 where group by order

索引尽量识别度高

尽量使用联合索引，索引过多影响优化器的效率

索引回表比例超过30% ，就考虑优化



or优化，union all (不一定好，可能查询次数增加)



group by的坑，采用子查询，先排序后查询



----

**join**

嵌套循环：



优化：（减少io的次数）

驱动表的选择，小表驱动大表

on关联使用主键或唯一索引

分析需要优化的部分。

考虑使用函数的部分，尽量用函数的作为驱动表





MySQL5.7，先解析内部表，在解析外部

函数可建立索引



----

# Redis

## 类型：

**string：**

- sds (简单动态字符串)，可以存储整数、浮点数、字符串

- 对整数、浮点数自增自减操作，对整个字符串或者部分字符串操作

- 最大512m

1. len属性保存字符串长度，时间复杂度o(1)

2. 预空间分配，小于1MB时，预分配和len相同的长度，大于1MB时，预分配1mb

3. 惰性空间释放，长度减少时，内存不会立即重新分配，而是保留记录下来，下次拼接时使用

4. 修改时，自动扩展空间，防止缓冲区溢出

#### 场景：缓存、限流、计数器、分布式锁、分布式session

**list：**

- 有序的链表结构

- 底层快速列表实现（quicklist）, 双端链表(linkedlist)和压缩列表(ziplist)的结合
- 可以实现数组(o(n))、栈（o(1)）、队列（o(1)）等

每个quicklist节点包含一个ziplist片段，之间使用链表连接。 ziplist是连续的空间，通过压缩减少链表键的碎片空间

**场景**：简单队列、时间轴、超卖、高并发、恶意请求



**hash**

- 底层采用ziplist或者hashtable存储。

- 当元素个数小于512个，并且键值对的建和字符串长度都小于64字节时，使用ziplist结构

- 否则使用hashtable存储。

1. hashtable避免hash冲突，使用链地址法解决（将相同hash值的对象组成一个链表放在hash值对应的槽位）

2. （重新散列）每个字段有两个hash表，当键组件增多或减少时，对hash表扩展或者收缩。将ht[0]中的键值对对分多次，渐进式的rehash到ht[1]里



**场景：**

购物车、保存键值对信息（比string+json灵活，但复杂度提高，方便更新某一个键）



**zset**

- 底层通过ziplist或skiplist实现，当元素过长时，使用skiplist存储。
- zadd zrem zrank 复杂度介于o(logn) ~o(n)
- 跳跃表复杂度o(logn)，和平衡二叉树相当，实现简单。是一种有序的数据结构，通过在节点中维持多个志向其他节点的指针，实现快速访问节点。

**场景：排行榜**

**set：**

- 自动去重的dict，value为null

- 底层使用intset或者hashtable数据结构。当元素全为整数且长度不大于512时，使用intset
- intset更节省空间，为有序的，无重复数组保存的集合元素。元素类型可以升级但不可逆
- intset删除和查找的复杂度为o(n)

场景：集合并集差集交集，



**sub/pub：**

- 发布订阅的数据结构是一个字典，键是被订阅的频道的键，值是一个链表，保存所有的客户端
- 消息不具备可靠性

- 不保存消息内容，只负责分发



**lua脚本：**

好处：

- 原子操作
- 减少网络请求
- 可以缓存脚本，提高效率

缺点：

- 没有垃圾回收，不能写太复杂的业务逻辑
- nil空字符判断问题



**缓存雪崩：**

大量缓存失效，给后端数据库带来太大压力

1. redis做集群高可用
2. 限流降级，热点数据选择降级
3. 缓存时间错开



**分布式锁：**

锁失效或死锁的应对：

锁加失效时间；

锁的值使用UUID，删除是判断是否是当前线程；



**内存淘汰策略：**

volatile-lru：从已设置过期时间的key中，选择使用空闲时间长的，不常用的key的删除

- 使用链表存储，会把常用的放到前面，不常用的往后放，当容量不足时，删除后面的

volatile-lfu：从已设置过期时间的key中，选择使用频率少的key的删除

默认策略不删除。



**多级缓存：**

不通过php，直接有NGINX返回：

浏览器（本地缓存） -》 NGINX（本地缓存）-》lua(redis) -> lua(mysql)

openresty()..

**主从复制：**



- 主节点会发送命令给从节点，主节点保存当前offset和左右从节点的offset。

- 从节点定期上报offset

- 当从节点断开重连时，发送psync，如果满足部分复制的条件（偏移量在复制缓冲区内）会部分复制，否则进行全量复制（这是一个耗时的过程，且会出现超时，主节点首先bgsave()，然后发送rdb文件，期间的命令保存在缓冲区中。等rdb传送完后在复制缓冲区内的命令，如果全量复制，从节点会清空本地数据，使用接收到的rdb文件，从节点接收完后，如果开启aof，还会bgrewriteaof）
- 心跳检测：从节点每10秒发送ping命令，每1秒上报offset
- 默认slave-only-read



**数据持久化：**

rdb：

- 快照，通过lzf算法压缩，数据体积远小于内存
- 恢复快，由于是fork出一个子进程，所以消耗少
- 缺点：实时性差，服务器宕机会丢失数据

触发时机：

- 主动bgsave
- 被动触发
- shutdown
- 全量复制时

aof：

- 保存执行命令，可以通过配置，多久写入一次，一般推荐每秒写入一次
- 体积会比rdb大，需要定时重写，缩减体积
- 新版重写时，是aof和rdb回合模式，先以rdb生成二进制快照的方式写入aof文件，重写期间命令追加到aof文件中，最后原子替换。

触发时机：

- 主动 bgrewriteaof
- 配置auto-aof-rewrite-min-size和（最小重写体积）auto-aof-rewrite-percentage（百分比）



主从时的配置策略，主关闭持久化，从开启aof或者rdb。注意自动拉起和不做就持久化不能同时存在，否则造成数据丢失和复制风暴。



**sentinel哨兵机制：**

- 理解，自动监控节点状态，完成新节点选取和故障转移
- 哨兵节点个数选择奇数个，确保选举。
- 每个哨兵节点每秒对其他节点ping消息，如果发现主节点在配置时间内没反应则主观下线
- 哨兵间都订阅主节点的消息，每2秒交换信息
- 哨兵节点每10秒对所有master和slave执行info repaication
- 当所有哨兵发现master不可达时，客观下线，选举出领导者进行故障转移和从节点复制。
- 领导者的选择需要得到配置票数时才可以当选领导者
- 根据 slave-priority , offset ， runid选择出合适新主节点



**Redis集群：**

虚拟槽（16834）

- 只需要一条命令，Redis就可以通过流言协议（gossip）建立集群，同时具备了sentinel的功能
- 为什么是16384，因为节点间要进行通信，CRC算法最大有65535个结果，65k，使用bitmap压缩完后是8k，太大。选择8k，压缩完2k，也就是16834正好。

----





# laravel

1. 核心：容器

核心功能注册，控制反转，依赖注入，反射都是通过容器实现

2. 门面：优雅。不需要显性的指出依赖，作为服务的静态代理
3. 契约（接口），定义一个标准，可替换可升级，作用就是解耦





----



**微服务架构：**



前景：

**高并发：**

- 拆分原则：
  - 系统维度：根据业务划分
  - 功能维度：比如秒杀
- 服务化：独立的业务，功能内聚，对外提供同统一标准的接口，不同服务间松耦合
- 通信：rpc 【直接调用方法】、 restful【通过api】 、 消息队列
  - 超时、重试，同步
  - 消息队列异步，解耦，会有延迟的问题
  - 对外，restful
- 数据异构：聚合多个表性能降低，考虑异构表
- 数据闭环：因数据源过多，为了提高性能，事先将数据打包在一起放在缓存。对实时性要求不高的

**大流量：**

- 负载均衡，增加负载能力
- 流量削峰

**高可用：**

- MySQL集群
- Redis集群
- es集群
- kafka
- MongoDB

**自动发布：**

- Jenkins + docker

**网关：**

-  

